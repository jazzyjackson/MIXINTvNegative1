const spawn = require('child_process').spawn
const stream = require('stream')
const url = require('url')
const querystring = require('querystring')
const util = require('util')
// POST requests and event streams can send via querystring:
// Stdin
// Argv
// Env
// Cwd
// Pathname is full path to executable
// Or single path part -> unshift argv
// Execute usr bin env
// Argv can be a string, a json encoded array, json encoded object that will be re encoded and passed to argv
module.exports = class Wireworker {
    // maybe this whole thing will make more sense just exporting the child
    // the event transform stream can be defined somewhere else
    // and the request piping can happen in switchboard instead of being hidden away in a module.
    /* create a strema transform that converts program output into ndjson,
       so program open, close, errors can all be handled as Object events
       so all of that will be streamed to disk
       and then you can decide to pipe raw result (for POST) or, POST headers.accept = ldjson, 
        application/x-ndjson -> streaming json, same format as written to pid-epoch
        // could use a program that takes ndjson pid-epoch data and rolls it into a single json. concatenating duplicate properties
        // ndjson-rollup - maybe jq will make this easy if I only concatenate to stdout and stderr
        application/json -> metadata complete stderr stdout json
        text/plain / default -> raw output
        */
    constructor(request, response){
        try {
            var subprocess = this.fork(request)
        } catch(err){
            // exit constructor, inform client of why request couldn't be forked
            response.writeHead(500)
            return response.end(util.inspect(err))
        }
        // this only continues if launching subprocess didn't throw an error
        if(/event-stream/.test(request.headers.accept)){
            response.setHeader('Content-Type', 'text/event-stream')
            let eventStream = new stream.Transform({
                /*** inside this transform `this` refers to the response stream ***/
                objectMode: true,
                transform: function(chunk, encoding, done){
                    if(chunk.constructor != Object){
                        // send strings as comments, used for heartbeat
                        this.push(`:${chunk}\n\n`) 
                    } else {
                        // send events as key name
                        // receiving eventsource will need to attach 
                        // event listeners to all possible object keys 
                        // in order to react to named events. 
                        // stdout/stderr/error/exit-code is a good place to start
                        this.push(Object.keys(chunk).map(key =>
                            `event:${key}\n`
                          + `data:${JSON.stringify(chunk[key])}\n`).join('\n')
                          + '\n')
                    }
                    done()
                }
            })
            eventStream.pipe(response)            
            // if subprocess was successful, pid will be assigned synchronously and we can send it back
            subprocess.pid && eventStream.write({ pid: subprocess.pid }) 
            let heartbeat = setInterval(() => {
                eventStream.write('lub-dub')
            }, 1000)
            subprocess.stdout.on('data', data => {
                // if subprocess is writing JSON to stdout, allow subprocess to dictate event names, otherwise name it stdout
                eventStream.write(tryJSON(data.toString()) || {stdout: data.toString()})
            })
            subprocess.stderr.on('data', data => {
                eventStream.write(tryJSON(data.toString()) || {stderr: data.toString()})
            })
            subprocess.on('close', (code,signal) => {
                // stop trying to send heartbeats
                clearInterval(heartbeat) // its okay if heartbeat was cleared already
                if(eventStream.writable == false) return null // exit if eventStream is already closed, likely due to being closed on error
                eventStream.end(signal ? {"exit-signal": signal }  // signal might be KILL or TERM or otherwise null
                                       : {  "exit-code": code   }) // if it was falsey, send exit code instead, which may be falsey. 0 is best case scenario
                // and close the connection. 
                // client should close the eventSource when receiving 'close' event,
                // otherwise closing the pipe throws an error clientside
                // and eventSource will attempt to reconnect 
            })
            subprocess.on('error', error => {
                // stop trying to send heartbeats
                clearInterval(heartbeat)
                eventStream.end({error: util.inspect(error)})
            })
        } else {
            // not acting as an event source? fine, stream back raw output
            response.setHeader('Content-Type', 'application/json')
            subprocess.stdout.on('data', data => {
                response.headersSent || response.writeHead(200)
                response.write(data)                
            })
            subprocess.stderr.on('data', data => {
                response.headersSent || response.writeHead(500)                
                response.write(data)
            })
            subprocess.on('error', error => {
                response.headersSent || response.writeHead(500)
                response.writable && response.end(util.inspect(error))
            })
            subprocess.on('close', (code, signal) => {
                // oh yeah, I wanted to send information about the exit code, but I can only send headers once, and I don't see a way to use trailers, so I guess I just have to eat this info it for now.
                // if process closes with nonzero code, and no data has been sent, writeHead as error
                if(code !== 0){
                    response.headersSent || response.writeHead(500)
                }
                // if it wasn't closed on error
                response.writable && response.end()
            })
        }
        // called when 
        response.on('close', function(){
            subprocess.stdout.pause().removeAllListeners('data').unpipe(this)
            subprocess.stderr.pause().removeAllListeners('data').unpipe(this)
            subprocess.removeAllListeners('close')
            console.log("socket closed unexpectedly while responding to " + request.url)
            // subprocess.writable ? subprocess.kill
        })

        response.on('finish', function(){     
            console.log("subprocess finished")
        })
 
    }

    fork(request){
        var urlObj = url.parse(request.url)
        var queryObj = querystring.decode(urlObj.query)
        for(var key in queryObj){
            // try converting each value from JSON, its okay if its just a string.
            queryObj[key] = tryJSON(queryObj[key]) || queryObj[key]
        }

        var pathname = urlObj.pathname
        var argv = []
        var cwd = queryObj.cwd || process.cwd()
        var env = queryObj.env || process.env

        if(queryObj.argv){
            // argv could be a single string, or an array of arguments, or an object that we want to pass as a single JSON argument
            switch(queryObj.argv.constructor){
                case Object:
                    argv.push(JSON.stringify(queryObj.argv))
                    break
                case Array:
                    argv.push(...queryObj.argv)
                    break
                case String:
                case Number:
                case Boolean:
                    argv.push(String(queryObj.argv))
            }
        }

        if(!pathname.slice(1).includes('/')){
            // if not a full path to an executable,
            // insert executable to the front of the argv array
            argv.unshift(pathname.slice(1))
            // overwrite pathname with /usr/bin/env to execute first argument
            pathname = '/usr/bin/env'
        }

        /* HEY! don't have both a body and a stdin in your querystring! querystring will take precedence
         * But really this is meant to allow POST with JSON body, and GET-event-stream with stdin querystring 
         * (cuz you cant have a JSON BODY on a GET) */
        /* finally, instantiate a child process */
        var child = spawn(pathname, argv, {cwd, env})

        if(queryObj.stdin && queryObj.stdin.constructor == Object){
            child.stdin.end(JSON.stringify(queryObj.stdin))
        } else if(queryObj.stdin){
            child.stdin.end(String(queryObj.stdin))
        } else if(request.method == 'POST') {
            request.pipe(child.stdin)
        }
        return child
    }
}

function tryJSON(string){
    // if it's parseable, return object, 
    // else, return undefined instead of throwing error
    try { return JSON.parse(string) } catch(err){} 
}
